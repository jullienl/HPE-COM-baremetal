---
# Performing automated ESXi 7.0 U3 installation on HPE Compute Ops Managmeent server(s) using an auto-generated ISO file with customized kickstart.
#
#  Command that can be used to run this playbook:
#   
#   $ ansible-playbook -i hosts_ESX ESXi70_provisioning.yml --ask-vault-password --ask-become-pass
#
#  Note: Make sure to provide the list of servers to be provisioned with their details in the inventory file 'hosts_ESX'
#
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------



# Adding a DNS record for the server that will be provisioned in the defined DNS server

#-------------------------------------- DNS record (WinRM Mode) -------------------------------------------------------------------------------------------------------

- name: DNS record for the bare metal ESXi server
  hosts: All
  gather_facts: no
  vars:
    ansible_forks: 5
  vars_files:
    - vars/Windows_DNS_vars_encrypted.yml
  tasks:
    - name: Add '{{ inventory_hostname }}' with '{{ os_ip_address }}' on '{{ dns_server }}' in '{{ domain }}' DNS domain
      community.windows.win_dns_record:
        name: "{{ inventory_hostname }}"
        type: "A"
        value: "{{ os_ip_address }}"
        zone: "{{ domain }}"
        state: present
      delegate_to: "{{ dns_server }}"

#-------------------------------------- Bare Metal Provisioning -------------------------------------------------------------------------------------------------------

- name: Automated ESXi 7.0 U3 installation on HPE Compute Ops Managmeent server(s) using an auto-generated ISO file with customized kickstart.
  hosts: All
  gather_facts: no
  vars_files:
    - vars/GLP_COM_API_credentials_encrypted.yml    
    - vars/VMware_vCenter_vars_encrypted.yml
    - vars/ESXi7.0.u3_vars.yml
  vars:
    inventory_fqdn: "{{ inventory_hostname | lower }}.{{ domain }}"
    ansible_host_key_checking: false
    validate_certs: false
    user: "{{ lookup('env', 'USER') }}"
    ssh_known_hosts_file: "{{ lookup('env','HOME') + '/.ssh/known_hosts' }}"
    ansible_ssh_public_key: "{{ lookup('file', '~/.ssh/id_rsa.pub') }}"
    ansible_forks: 5

  tasks:

#--------------------------------------Capture start time--------------------------------------------------------------------------------------------------------------

  - name: Gather subset facts on localhost
    setup:
      gather_subset: [all]
    delegate_to: localhost

  - name: Capture the start time (will be used later to filter COM activities and get the runtime of the playbook)
    set_fact:
      start_time: "{{ ansible_date_time.iso8601 }}"
      # yesterday_date: "{{ '%Y-%m-%dT%H:%M:%SZ' | strftime(ansible_date_time.epoch | int - (24 * 3600)) }}"
  
  - debug: var=start_time
      

#--------------------------------------Authentication with COM---------------------------------------------------------------------------------------------------------

  - name: Create HPE Compute Ops Management session
    import_tasks: files/Create_COM_session.yml


#--------------------------------------Capture COM resource API versions ----------------------- ----------------------------------------------------------------------

  - name: Capture Resource API versions
    import_tasks: files/Get_resource_API_versions.yml


#--------------------------------------Capture Job Templates Resource Uri-----------------------------------------------------------------------------------------------
  
  - name: Capture Job Templates ResourceUri
    import_tasks: files/Get_job_templates_resourceuri.yml


#--------------------------------------Capture server information -----------------------------------------------------------------------------------------------------

  - name: Capture server '{{ serial_number }}' information
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ servers_API_version }}/servers?filter=hardware/serialNumber%20eq%20'{{ serial_number }}'"
      method: GET
      headers:
        Authorization: "Bearer {{ access_token }}"
    register: server
    delegate_to: localhost

  # - debug: var=server

  - name: Exit if server '{{ serial_number }}' does not exist
    fail:
      msg: "Server '{{ serial_number }}' does not exist!"
    when: server.json.count == 0

  - name: Capture server '{{ serial_number }}' generation, id, uri, connection status and iLO IP
    set_fact:
      server_generation:  "{{ server | json_query('json.items[0].serverGeneration') }}"
      server_id:  "{{ server | json_query('json.items[0].id') }}"
      server_resourceUri:  "{{ server | json_query('json.items[0].resourceUri') }}"
      server_connected_status:  "{{ server | json_query('json.items[0].state.connected') }}"
      server_ilo_ip:  "{{ server | json_query('json.items[0].hardware.bmc.ip') }}"

  - debug: 
      msg:
        - "Generation: {{ server_generation }}"
        - "ID: {{ server_id }}"
        - "URI: {{ server_resourceUri }}"
        - "Connection status: {{ server_connected_status }}"
        - "iLO IP: {{ server_ilo_ip }}"

  - name: Exit if server '{{ serial_number }}' is not connected to COM
    fail:
      msg: 
        - "Server '{{ serial_number }}' is not connected to COM!" 
        - "Make sure to connect the server's iLO to COM ! Go to iLO UI / Management / Compute Ops Management"
    when: server_connected_status == false

  - name: Wait until the server '{{ serial_number }}' raw inventory information is available (necessary when the server has recently been added to COM) then capture the data
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ servers_API_version }}/servers/{{ server_id }}/raw-inventory"
      method: GET
      headers:
        Authorization: "Bearer {{ access_token }}"
    register: server_raw_inventory
    failed_when: server_raw_inventory.status != 200 and server_raw_inventory.status != 404
    until: server_raw_inventory.status == 200 
    retries: 30
    delay: 60
    delegate_to: localhost
    
  - name: Wait until the complete discovery of server '{{ serial_number }}' is complete (necessary when the server has recently been added to COM).
    uri:
      url: "{{ ConnectivityEndpoint }}/ui-doorway/compute/v2/servers/{{ server_id }}"
      method: GET
      return_content: yes
      status_code: 200
      headers:
        Authorization: "Bearer {{ access_token }}"
    register: server_inventory_from_ui_doorway
    until: server_inventory_from_ui_doorway.json.state_ != "Retrieving server information in progress" 
    retries: 30
    delay: 60
    delegate_to: localhost
    

#--------------------------------------Check BIOS/Workload profile settings -------------------------------------------------------------------------------------------

  # BIOS/Workload profiles are predefined by HPE, so there's no need to create/update them, just check that they exist. 

  - name: Check if workload profile '{{ workload_profile_name }}' exists
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ server_settings_API_version }}/server-settings?filter={{ filter | urlencode }}"
      method: GET
      headers:
        Authorization: "Bearer {{ access_token }}"
    vars:
      filter: "category eq 'BIOS' and name eq '{{ workload_profile_name }}'"
    register: bios_server_setting
    delegate_to: localhost

  # - debug: var=bios_server_setting

  - name: Exit if workload profile '{{ workload_profile_name }}' does not exist
    fail:
      msg: "Workload profile '{{ workload_profile_name }}' does not exist!"
    when: bios_server_setting.json.count == 0

  - name: Set a variable for the resourceUri of workload profile '{{ workload_profile_name }}'
    set_fact: 
      bios_server_setting_resourceuri: "{{ bios_server_setting | json_query('json.items[0].resourceUri') }}"   
    
  # - debug: var=bios_server_setting_resourceuri


#--------------------------------------Create internal storage settings -----------------------------------------------------------------------------------------------

  - name: Wait until PCI devices information is available then capture the server '{{ serial_number }}' raw inventory information 
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ servers_API_version }}/servers/{{ server_id }}/raw-inventory"
      method: GET
      headers:
        Authorization: "Bearer {{ access_token }}"
    register: server_raw_inventory
    # until: (server_raw_inventory.json.pciDevices | length>0)
    until: server_raw_inventory.json.pciDevices is defined and server_raw_inventory.json.pciDevices is not none
    retries: 30
    delay: 60
    delegate_to: localhost

 # Run a server inventory job to collect the local storage information

  - name: Run a server inventory job to collect the local storage information
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ jobs_API_version }}/jobs"
      method: POST
      status_code: 200
      headers:
        Authorization: "Bearer {{ access_token }}"
        Content-Type: "application/json"
      body_format: json
      body:
        resourceUri: "{{ server_resourceUri }}"
        jobTemplateUri: "{{ GetFullServerInventory_job_template_resourceUri }}"
        data:
          is_reports_call: true
          filters: 
            - localStorageV2
    register: inventory_job_result
    delegate_to: localhost

  # - debug: var=inventory_job_result

  - name: Set a variable for the job resource URI
    set_fact:
      job_resourceUri: "{{ inventory_job_result.json.resourceUri }}"

  # - debug: var=job_resourceUri

  - name: Wait for the server inventory job to complete
    uri:
      url: "{{ ConnectivityEndpoint }}{{ job_resourceUri }}"
      method: GET
      return_content: yes
      headers:
        Authorization: "Bearer {{ access_token }}"
    retries: 60
    delay: 5
    until: >
      (server_inventory_job_status.json.state == "COMPLETE" or 
      server_inventory_job_status.json.state == "ERROR")
    register: server_inventory_job_status
    delegate_to: localhost

  # - debug: var=server_inventory_job_status

  - name: Display the server inventory job result 
    debug: 
      msg:
        - "State: {{ server_inventory_job_status.json.state }}"
        - "ResultCode: {{ server_inventory_job_status.json.resultCode }}"
        - "Status: {{ server_inventory_job_status.json.status }}"

  - name: Exit when server inventory job is failing
    fail: 
      msg: "Error ! Server inventory job to collect the local storage information has failed !"
    when: server_inventory_job_status.json.state == "ERROR" 

  - name: Capture the server '{{ serial_number }}' raw inventory information 
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ servers_API_version }}/servers/{{ server_id }}/raw-inventory"
      method: GET
      headers:
        Authorization: "Bearer {{ access_token }}"
    register: server_raw_inventory
    delegate_to: localhost

  # - debug: var=server_raw_inventory

  # Is the server equipped with an NVMe NS204i boot controller?

  - name: Capture the presence of a NS204i NVMe boot controller in server '{{ serial_number }}'
    set_fact:
      NS204i_data: "{{ matched_item }}"
    vars:
        matched_item: "{{ item }}"
    loop: "{{ server_raw_inventory.json.storageInventory.LocalStorageV2 }}"
    loop_control:
      label: never
    when: item.Name is search('NS204i')

  # - debug: var=NS204i_data

  - debug:
     msg: "NS204i found in server '{{ serial_number }}'! NVMe RAID1 volume will be used as the target volume for the installation of ESXi!"
    when: NS204i_data is defined
  
  - debug:
     msg: "No NS204i found in server '{{ serial_number }}'! Let's check if a storage controller with drives is available..."
    when: NS204i_data is undefined

  # - debug: var=server_raw_inventory.json.storageInventory

  - name: Capture size of the NS204i RAID1 volume if any
    set_fact:
      boot_drive_bytes_size: "{{ matched_item }}"
    vars:
        matched_item: "{{ item.Volumes[0].CapacityBytes }}"
    loop: "{{ server_raw_inventory.json.storageInventory.LocalStorageV2 }}"
    loop_control:
      label: never
    when: NS204i_data is defined and item.Name is search('NS204i')
    
  - debug: 
      msg: "Size of NS204i volume: {{ ((boot_drive_bytes_size | int) / (1024 ** 3)) | round(1) }} GB"
    when: NS204i_data is defined 

   # No NS204i but is the server equipped with an HPE MR or SR controller and with drives available?

  - name: Capture storage RAID controller information when an HPE MR or SR controller is used with available drives
    set_fact:
      SR_MR_storage_controller_data: "{{ matched_item }}"
    vars:
        matched_item: "{{ item }}"
    loop: "{{ server_raw_inventory.json.storageInventory.LocalStorageV2 }}"
    loop_control:
      label: never
    when: NS204i_data is undefined and item.Drives | length > 0 and (item.Name is search('HPE MR') or item.Name is search('HPE SR'))

  # - debug: var=SR_MR_storage_controller_data

  - name: Set a variable for the name of the storage RAID controller found
    set_fact:
      storage_controller_name: "{{ SR_MR_storage_controller_data.Name }}"
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined
    
  - debug: 
      msg: "Storage RAID controller found: '{{ storage_controller_name }}' with '{{ SR_MR_storage_controller_data.Drives | length }}' drives"
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined

  # Retrieve storage controller data when no NS204i and no SR/MR controller with disk available found  

  - name: Set controller type if disk found and when no NS204i and no SR/MR controller with disk available found     
    set_fact:
      no_NS204i_no_SR_MR_but_local_disk: "{{ matched_item }}"
    vars:
        matched_item: "{{ item }}"
    loop: "{{ server_raw_inventory.json.storageInventory.LocalStorageV2 }}"
    loop_control:
      label: never
    when: NS204i_data is undefined and SR_MR_storage_controller_data is undefined and item.Drives | length > 0

  # - debug: var=no_NS204i_no_SR_MR_but_local_disk

  - name: Exit when no NS204i and no SR/MR controller and no other controller with disks are found
    fail: 
      msg: "Error ! No controller found with disk available !"
    when: NS204i_data is undefined and SR_MR_storage_controller_data is undefined and no_NS204i_no_SR_MR_but_local_disk is undefined

  - name: Set a variable for the name of the storage controller found
    set_fact:
      storage_controller_name: "{{ no_NS204i_no_SR_MR_but_local_disk.Name }}"
    when: NS204i_data is undefined and SR_MR_storage_controller_data is undefined 

  - debug: 
      msg: "Storage controller found: '{{ storage_controller_name }}' with '{{ no_NS204i_no_SR_MR_but_local_disk.Drives | length }}' drives"
    when: NS204i_data is undefined and SR_MR_storage_controller_data is undefined 

  # Set controller type name for kickstart creation

  - name: Set controller type when no NS204i and no SR/MR controller with disk available found     
    set_fact:
      Controller_type: "Local"
    when: NS204i_data is undefined and SR_MR_storage_controller_data is undefined and no_NS204i_no_SR_MR_but_local_disk is defined

  - name: Set a controller type variable for kickstart creation when an NS204i is present
    set_fact:
      Controller_type: "NS204i"
    when: NS204i_data is defined 

  - name: Set a controller type variable for kickstart creation when there is no NS204i but an SR/MR controller is present.
    set_fact:
      Controller_type: "{{ storage_controller_name }}"
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined

  - debug: 
      msg: "Controller type found that will be used by kickstart: {{ Controller_type }}"   

  # Server settings for internal storage RAID configuration (creation or modification)

  - name: Check if server settings '{{ raid_type }}' already exist
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ server_settings_API_version }}/server-settings?filter={{ filter | urlencode }}"
      method: GET
      headers:
        Authorization: "Bearer {{ access_token }}"
    vars:
      filter: "name eq '{{ raid_type }}'"
    register: internal_storage_server_setting
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined
    delegate_to: localhost

  # - debug: var=internal_storage_server_setting

  # Need to create an internal storage RAID configuration if there is no NS204i but there is a storage controller
  - name: Create internal storage configuration using '{{ raid_type }}' with a volume size of '{{ volume_size_in_GB }}' GB for the OS boot volume when it does not exist
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ server_settings_API_version }}/server-settings"
      method: POST
      status_code: 201
      headers:
        Authorization: "Bearer {{ access_token }}"
        Content-Type: "application/json"
      body_format: json
      body:
        name: "{{ raid_type }}"
        description: "Local storage settings using {{ raid_type }} for OS"
        platformFamily: "Any"
        category:  "STORAGE"
        settings:
          DEFAULT:
            raidType:  "{{ raid_type }}"         
            volumeSizeInGB: "{{ volume_size_in_GB }}"
    register: internal_storage_server_setting_result
    delegate_to: localhost
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined and internal_storage_server_setting.json.count == 0

  - name: Result of the '{{ raid_type }}' creation task
    debug: var=internal_storage_server_setting_result
    when:  NS204i_data is undefined and SR_MR_storage_controller_data is defined and internal_storage_server_setting.json.count == 0

  - name: Set a variable for the resourceUri of the internal storage configuration '{{ raid_type }}' just created
    set_fact: 
      internal_storage_server_setting_resourceuri: "{{ internal_storage_server_setting_result.json.resourceUri }}"
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined and internal_storage_server_setting.json.count == 0

  - name: Update internal storage configuration using '{{ raid_type }}' with a volume size of '{{ volume_size_in_GB }}' GB for the OS boot volume 
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ server_settings_API_version }}/server-settings/{{ internal_storage_server_setting_id }}"
      method: PATCH
      status_code: 200
      headers:
        Authorization: "Bearer {{ access_token }}"
        Content-Type: "application/merge-patch+json"
      body_format: json
      body:
        name: "{{ raid_type }}"
        description: "Local storage settings using {{ raid_type }} for OS"
        platformFamily: "Any"
        category:  "STORAGE"
        settings:
          DEFAULT:
            raidType:  "{{ raid_type }}"         
            volumeSizeInGB: "{{ volume_size_in_GB }}"
    vars: 
      internal_storage_server_setting_id: "{{ internal_storage_server_setting  | json_query('json.items[0].id') }}"
    register: internal_storage_server_setting_result
    delegate_to: localhost
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined and internal_storage_server_setting.json.count == 1

  - name: Result of the '{{ raid_type }}' update task
    debug: var=internal_storage_server_setting_result.msg
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined and internal_storage_server_setting.json.count == 1

  - name: Set a variable for the resourceUri of the internal storage configuration '{{ raid_type }}' just updated
    set_fact: 
      internal_storage_server_setting_resourceuri: "{{ internal_storage_server_setting | json_query('json.items[0].resourceUri') }}"
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined and internal_storage_server_setting.json.count == 1  

  - debug: var=internal_storage_server_setting_resourceuri
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined


#--------------------------------------Create temporary server group with server settings -----------------------------------------------------------------------------

  # Create a temporary group name from hostname + _server_group

  - name: Create server group name '{{ inventory_hostname }}_server_group' variable
    set_fact:
      temporary_server_group_name: "{{ inventory_hostname }}_server_group" 

  # Group is created or modified based on whether this particular resource is present or not
  
  - name: Check if group '{{ temporary_server_group_name }}' already exists
    uri:
      url:  "{{ ConnectivityEndpoint }}/compute-ops/{{ groups_API_version }}/groups?filter={{ filter | urlencode }}"
      method: GET
      headers:
        Authorization: "Bearer {{ access_token }}"
    vars: 
      filter: "name eq '{{ temporary_server_group_name }}'"      
    register: temporary_server_group
    delegate_to: localhost

  # - debug: var=temporary_server_group

  # Server group creation or modification when NS204i is found or when no_NS204i_no_SR_MR_but_local_disk => no local storage configuration definition

  - name: Create temporary group '{{ temporary_server_group_name }}' with no local storage configuration definition (if it does not exist)
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ groups_API_version }}/groups"
      method: POST
      status_code: 201
      headers:
        Authorization: "Bearer {{ access_token }}"
        Content-Type: "application/json"
      body_format: json
      body:
        name: "{{ temporary_server_group_name }}"
        description: "Temporary server group for ESXi installation on server '{{ inventory_hostname }}'"
        serverSettingsUris: 
          - "{{ bios_server_setting_resourceuri }}"     
        serverPolicies:
          onServerAdd:
            firmwareUpdate: false
            biosApplySettings: true
            storageConfiguration: false
            storageVolumeDeletion: false
            storageVolumeName: ""
            osInstall: false
          onSettingsApply:
            firmwareDowngrade: false
        # autoAddServerTags:
    register: server_group_result
    when: (NS204i_data is defined or no_NS204i_no_SR_MR_but_local_disk is defined) and temporary_server_group.json.count == 0
    delegate_to: localhost

  - name: Display response of the temporary group '{{ temporary_server_group_name }}' creation request
    debug: var=server_group_result.msg
    when: (NS204i_data is defined or no_NS204i_no_SR_MR_but_local_disk is defined) and temporary_server_group.json.count == 0

  - name: Set variables for the id and the resourceUri of temporary group '{{ temporary_server_group_name }}' just created
    set_fact:
      temporary_group_id: "{{ server_group_result.json.id }}" 
      temporary_group_resourceuri: "{{ server_group_result.json.resourceUri }}"
    when: (NS204i_data is defined or no_NS204i_no_SR_MR_but_local_disk is defined) and temporary_server_group.json.count == 0
  
  - name: Update temporary group '{{ temporary_server_group_name }}' with no local storage configuration definition (if it does exist)
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ groups_API_version }}/groups/{{ group_id }}"
      method: PATCH
      status_code: 200
      headers:
        Authorization: "Bearer {{ access_token }}"
        Content-Type: "application/merge-patch+json"
      body_format: json
      body:
        name: "{{ temporary_server_group_name }}"
        description: "Temporary server group for ESXi installation on server '{{ inventory_hostname }}'"
        serverSettingsUris: 
          - "{{ bios_server_setting_resourceuri }}"   
        serverPolicies:
          onServerAdd:
            firmwareUpdate: false
            biosApplySettings: true
            storageConfiguration: false
            storageVolumeDeletion: false
            storageVolumeName: ""
            osInstall: false
          onSettingsApply:
            firmwareDowngrade: false
        # autoAddServerTags:
    vars: 
      group_id: "{{ temporary_server_group  | json_query('json.items[0].id') }}"
    register: server_group_result
    when: (NS204i_data is defined or no_NS204i_no_SR_MR_but_local_disk is defined) and temporary_server_group.json.count == 1
    delegate_to: localhost

  - name: Display response of the temporary group '{{ temporary_server_group_name }}' update request
    debug: var=server_group_result.msg
    when: (NS204i_data is defined or no_NS204i_no_SR_MR_but_local_disk is defined) and temporary_server_group.json.count == 1

  - name: Set variables for the id and the resourceUri of temporary group '{{ temporary_server_group_name }}' just updated
    set_fact:
      temporary_group_id: "{{ temporary_server_group | json_query('json.items[0].id') }}" 
      temporary_group_resourceuri: "{{ temporary_server_group | json_query('json.items[0].resourceUri') }}"
    when: (NS204i_data is defined or no_NS204i_no_SR_MR_but_local_disk is defined) and temporary_server_group.json.count == 1

  # Server group creation or modification when NS204i is not found but storage controller is found => with local storage RAID configuration definition

  - name: Create temporary group '{{ temporary_server_group_name }}' with local storage configuration definition (if it does not exist)
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ groups_API_version }}/groups"
      method: POST
      status_code: 201
      headers:
        Authorization: "Bearer {{ access_token }}"
        Content-Type: "application/json"
      body_format: json
      body:
        name: "{{ temporary_server_group_name }}"
        description: "Temporary server group for ESXi installation on server '{{ inventory_hostname }}'"
        serverSettingsUris: 
          - "{{ bios_server_setting_resourceuri }}"   
          - "{{ internal_storage_server_setting_resourceuri }}"       
        serverPolicies:
          onServerAdd:
            firmwareUpdate: false
            biosApplySettings: true
            storageConfiguration: true
            storageVolumeDeletion: true
            storageVolumeName: "OS_boot_volume"
            osInstall: false
          onSettingsApply:
            firmwareDowngrade: false
        # autoAddServerTags:
    register: server_group_result
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined and temporary_server_group.json.count == 0
    delegate_to: localhost

  - name: Display response of the temporary group '{{ temporary_server_group_name }}' creation request
    debug: var=server_group_result.msg
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined and temporary_server_group.json.count == 0

  - name: Set variables for the id and the resourceUri of temporary group '{{ temporary_server_group_name }}' just created
    set_fact:
      temporary_group_id: "{{ server_group_result.json.id }}" 
      temporary_group_resourceuri: "{{ server_group_result.json.resourceUri }}"
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined and temporary_server_group.json.count == 0
  
  - name: Update temporary group '{{ temporary_server_group_name }}' with local storage configuration definition (if it does exist)
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ groups_API_version }}/groups/{{ group_id }}"
      method: PATCH
      status_code: 200
      headers:
        Authorization: "Bearer {{ access_token }}"
        Content-Type: "application/merge-patch+json"
      body_format: json
      body:
        name: "{{ temporary_server_group_name }}"
        description: "Temporary server group for ESXi installation on server '{{ inventory_hostname }}'"
        serverSettingsUris: 
          - "{{ bios_server_setting_resourceuri }}"   
          - "{{ internal_storage_server_setting_resourceuri }}"           
        serverPolicies:
          onServerAdd:
            firmwareUpdate: false
            biosApplySettings: true
            storageConfiguration: true
            storageVolumeDeletion: true
            storageVolumeName: "OS_boot_volume"
            osInstall: false
          onSettingsApply:
            firmwareDowngrade: false
        # autoAddServerTags:
    vars: 
      group_id: "{{ temporary_server_group  | json_query('json.items[0].id') }}"
    register: server_group_result
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined and temporary_server_group.json.count == 1
    delegate_to: localhost

  - name: Display response of the temporary group '{{ temporary_server_group_name }}' update request
    debug: var=server_group_result.msg
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined and temporary_server_group.json.count == 1

  - name: Set variables for the id and the resourceUri of temporary group '{{ temporary_server_group_name }}' just updated
    set_fact:
      temporary_group_id: "{{ temporary_server_group | json_query('json.items[0].id') }}" 
      temporary_group_resourceuri: "{{ temporary_server_group | json_query('json.items[0].resourceUri') }}"
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined and temporary_server_group.json.count == 1

  - debug: var=temporary_group_id

  - debug: var=temporary_group_resourceuri


#--------------------------------------Add server to temporary server group for server configuration ------------------------------------------------------------------

  - name: Check if server '{{ serial_number }}' is already member of a server group 
    uri:
      url: "{{ ConnectivityEndpoint }}/ui-doorway/compute/v2/servers/{{ server_id }}"
      method: GET
      status_code: 200
      headers:
        Authorization: "Bearer {{ access_token }}"
    register: server_info_from_ui_doorway
    delegate_to: localhost

  # - debug: var=server_info_from_ui_doorway

  - debug: var=server_info_from_ui_doorway.json.group_
    when: server_info_from_ui_doorway.json.group_ is defined

  - name: Capture the id of the server group of which the server '{{ serial_number }}' is a member (if applicable)
    set_fact:
      server_group_id_found: "{{ server_info_from_ui_doorway.json.group_.id }}"
      server_group_name_found: "{{ server_info_from_ui_doorway.json.group_.name }}"
    when: server_info_from_ui_doorway.json.group_ is not none and server_info_from_ui_doorway.json.group_ is defined

  - debug: var=server_group_name_found
    when: server_info_from_ui_doorway.json.group_ is not none and server_info_from_ui_doorway.json.group_ is defined

  - name: Remove server '{{ serial_number }}' from the server group of which it is currently a member
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ groups_API_version }}/groups/{{ server_group_id_found }}/devices/{{ server_id }}"
      method: DELETE
      status_code: 204
      headers:
        Authorization: "Bearer {{ access_token }}"
    when: server_info_from_ui_doorway.json.group_ is not none and server_info_from_ui_doorway.json.group_ is defined
    register: group_unassignment_result
    delegate_to: localhost

  - name: Wait for deletion to complete
    pause:
      seconds: 15
    when: server_info_from_ui_doorway.json.group_ is not none and server_info_from_ui_doorway.json.group_ is defined
    
  # Add server to the temporary server group 

  - name: Assign server '{{ serial_number }}' to temporary group '{{ temporary_server_group_name }}'
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ groups_API_version }}/groups/{{ temporary_group_id }}/devices"
      method: POST
      headers:
        Authorization: "Bearer {{ access_token }}"
        Content-Type: "application/json"
      body_format: json
      body:
        devices:
          # Only servers that are not part of a group can be assigned to a group.
          - serverId: "{{ server_id }}"
    register: group_assignment_result
    delegate_to: localhost

  - name: Display response of the group assignment task
    debug: var=group_assignment_result.msg


#--------------------------------------Monitor the server configuration status ----------------------------------------------------------------------------------------
  
  # Wait for the server configuration to complete 

  - name: Display the url that will be used to monitor the server configuration activity task
    debug:
      msg: "{{ ConnectivityEndpoint }}/compute-ops/{{ activities_API_version }}/activities?filter=associatedServerId eq '{{ server_id }}' and createdAt gt {{ start_time }}"
      
  - name: Wait for the configuration of server '{{ serial_number }}' to complete 
    uri:
      url:  "{{ ConnectivityEndpoint }}/compute-ops/{{ activities_API_version }}/activities?filter={{ filter | urlencode  }}"  
      method: GET
      headers:
        Authorization: "Bearer {{ access_token }}"
    vars: 
      filter: "associatedServerId eq '{{ server_id }}' and createdAt gt {{ start_time }}"      
      query: "json.items[? name=='Server automatic configuration' && (contains(message,'Automatic configuration of server is complete') || contains(message,'failed'))]"
    register: server_activities
    until: server_activities | json_query(query) 
    retries: 30
    delay: 60
    delegate_to: localhost

  - name: Exit if configuration of server '{{ serial_number }}' failed to complete
    fail:
      msg: "The configuration of server '{{ serial_number }}' failed to complete! Refer to the individual server activity entries in GLCP UI for details."
    vars:
      query: "json.items[? name=='Server automatic configuration' && contains(message,'failed')]"
    when: server_activities | json_query(query) 

  # Run a server inventory job to collect the local storage information

  - name: Run a server inventory job to collect the local storage information
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ jobs_API_version }}/jobs"
      method: POST
      status_code: 200
      headers:
        Authorization: "Bearer {{ access_token }}"
        Content-Type: "application/json"
      body_format: json
      body:
        resourceUri: "{{ server_resourceUri }}"
        jobTemplateUri: "{{ GetFullServerInventory_job_template_resourceUri }}"
        data:
          is_reports_call: true
          filters: 
            - localStorageV2
    register: inventory_job_result
    delegate_to: localhost

  # - debug: var=inventory_job_result

  - name: Set a variable for the job resource URI
    set_fact:
      job_resourceUri: "{{ inventory_job_result.json.resourceUri }}"

  # - debug: var=job_resourceUri

  - name: Wait for the server inventory job to complete
    uri:
      url: "{{ ConnectivityEndpoint }}{{ job_resourceUri }}"
      method: GET
      return_content: yes
      headers:
        Authorization: "Bearer {{ access_token }}"
    retries: 60
    delay: 5
    until: >
      (server_inventory_job_status.json.state == "COMPLETE" or 
      server_inventory_job_status.json.state == "ERROR")
    register: server_inventory_job_status
    delegate_to: localhost

  # - debug: var=server_inventory_job_status

  - name: Display the server inventory job result 
    debug: 
      msg:
        - "State: {{ server_inventory_job_status.json.state }}"
        - "ResultCode: {{ server_inventory_job_status.json.resultCode }}"
        - "Status: {{ server_inventory_job_status.json.status }}"

  - name: Exit when server inventory job is failing
    fail: 
      msg: "Error ! Server inventory job to collect the local storage information has failed !"
    when: server_inventory_job_status.json.state == "ERROR" 

 # Capture the size of the volume created once the server configuration is complete only when NS204i is not found with Storage RAID controller

  - name: Capture server '{{ serial_number }}' raw inventory information
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ servers_API_version }}/servers/{{ server_id }}/raw-inventory"
      method: GET
      headers:
        Authorization: "Bearer {{ access_token }}"
    register: server_raw_inventory
    delegate_to: localhost
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined
  
  # - debug: var=server_raw_inventory
  
  - name: Capture storage RAID controller information when an HPE MR or SR controller is used with available drives
    set_fact:
      SR_MR_storage_controller_data: "{{ matched_item }}"
    vars:
        matched_item: "{{ item }}"
    loop: "{{ server_raw_inventory.json.storageInventory.LocalStorageV2 }}"
    loop_control:
      label: never
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined and item.Name == storage_controller_name 
   
  - name: Capture the size of the OS volume configured on the {{ storage_controller_name }}
    set_fact:
      boot_drive_bytes_size: "{{ (SR_MR_storage_controller_data |  json_query(query))[0]  }}"
    vars:
      query: "Volumes[?Name=='OS_boot_volume'].CapacityBytes"
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined
    
  - debug: var=boot_drive_bytes_size
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined

  - name: Set the size of the OS volume as '0' with local disk
    set_fact:
      boot_drive_bytes_size: "0"
    when: no_NS204i_no_SR_MR_but_local_disk is defined
        
  - debug: 
      msg: "Size of RAID volume: {{ ((boot_drive_bytes_size | int) / (1024 ** 3)) | round(1) }} GB"
    when: NS204i_data is undefined and SR_MR_storage_controller_data is defined


#--------------------------------------Build ISO image with customized kickstart --------------------------------------------------------------------------------------

  - name: Check if HPE ESXi Custom ISO file '{{ src_iso_file }}' exists in '{{ src_iso_directory }}' on '{{lookup("pipe","hostname")}}' 
    stat:
      path: "{{ src_iso_directory }}/{{ src_iso_file }}"
    register: ISO_Present
    delegate_to: localhost

  - name: Create the directory '{{ src_iso_directory }}' to host the ISO file on '{{ lookup("pipe","hostname") }}'
    file:
      path: "{{ src_iso_directory }}"
      state: directory
    when: ISO_Present.stat.exists == False
    delegate_to: localhost

  - name: Check if ESXi ISO '{{ src_iso_url }}/{{ src_iso_file }}' exists  
    uri:
      url: "{{ src_iso_url }}/{{ src_iso_file }}"
      method: HEAD
      status_code: 200 # The HTTP status code for a successful request.
      validate_certs: false
    when: ISO_Present.stat.exists == False
    delegate_to: localhost

  - name: Download file '{{ src_iso_file }}' to '{{ lookup("pipe","hostname") }}' in '{{ src_iso_directory }}' if not present
    get_url:
      url: "{{ src_iso_url }}/{{ src_iso_file }}"
      dest: "{{ src_iso_directory }}"
      validate_certs: no
    when: ISO_Present.stat.exists == False
    delegate_to: localhost

  - name: Create '/mnt/{{ inventory_hostname }}' on '{{lookup("pipe","hostname")}}' if it does not exist
    become: yes
    file:
      path: /mnt/{{ inventory_hostname }}
      state: directory
      mode: "0755"
    delegate_to: localhost

  - name: Create '{{ staging_directory }}/baremetal/{{ inventory_hostname }}/' on '{{lookup("pipe","hostname")}}' if it does not exist
    file:
      path: "{{ staging_directory }}/baremetal/{{ inventory_hostname }}"
      state: directory
    delegate_to: localhost

  - name: Mount ESXi ISO '{{ src_iso_directory }}/{{ src_iso_file }}' to '/mnt/{{ inventory_hostname }}/' 
    become: yes
    shell: 
      mount -o loop -t iso9660 --read-only {{ src_iso_directory }}/{{ src_iso_file }} /mnt/{{ inventory_hostname }}/
    delegate_to: localhost

  - name: Copy ISO files to '{{ staging_directory }}/baremetal/{{ inventory_hostname }}/' on '{{lookup("pipe","hostname")}}' 
    shell: |
      rsync -a /mnt/{{ inventory_hostname }}/. {{ staging_directory }}/baremetal/{{ inventory_hostname }}/
    delegate_to: localhost

  - name: Set permissions to allow the user running the Ansible playbook to delete the folder '{{ staging_directory }}/baremetal/{{ inventory_hostname }}'
    become: yes
    file:
      path: "{{ staging_directory }}/baremetal/{{ inventory_hostname }}"
      mode: ug+w
      owner: "{{ user }}"
      group: "{{ user }}"
      recurse: yes
      state: directory
    delegate_to: localhost

  - name: Unmount directory '/mnt/{{ inventory_hostname }}'
    become: yes
    shell: 
      umount /mnt/{{ inventory_hostname }}
    delegate_to: localhost

  - name: Modify UEFI bootloader for kickstart installation from CDROM
    shell: 
      sed -i 's/kernelopt=cdromBoot runweasel/kernelopt=runweasel ks=cdrom:\/KS.CFG/' {{ staging_directory }}/baremetal/{{ inventory_hostname }}/efi/boot/boot.cfg
    delegate_to: localhost

  # Creation of the KS.CFG kickstart file

  - name: Create kickstart file in '{{ staging_directory }}/baremetal/{{ inventory_hostname }}/' on '{{lookup("pipe","hostname")}}' with variable substitution
    template:
      src: files/{{ esxi_build }}/{{ kickstart }}
      dest: "{{ staging_directory }}/baremetal/{{ inventory_hostname }}/KS.CFG"
    delegate_to: localhost

  # Creation of the new ESXi ISO image with unattended installation

  - name: Create customized bootable ISO in '{{ staging_directory }}/baremetal/{{ inventory_hostname }}/'
    # become: yes
    shell: >
      mkisofs
      -relaxed-filenames
      -J
      -R
      -b isolinux.bin -iso-level 2
      -c boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table
      -eltorito-alt-boot -eltorito-boot efiboot.img -no-emul-boot
      -o {{ staging_directory }}/baremetal/{{ inventory_hostname }}.iso
      {{ staging_directory }}/baremetal/{{ inventory_hostname }}/
    delegate_to: localhost

  - name: Create '/usr/share/nginx/html/isos/' on '{{lookup("pipe","hostname")}}' if it does not exist
    become: yes
    file:
      path: /usr/share/nginx/html/isos/
      state: directory
      mode: "0755"
    delegate_to: localhost

  - name: Move created ISO to the nginx default html folder. ISO URL='http://{{ lookup("pipe","hostname") }}/isos/{{ inventory_hostname }}.iso'
    become: yes
    shell: |
      mv {{ staging_directory }}/baremetal/{{ inventory_hostname }}.iso /usr/share/nginx/html/isos/
    delegate_to: localhost

  - name: Update SELinux security contexts so that Nginx is allowed to serve content from the '/usr/share/nginx/html/isos/' directory.
    become: yes
    shell: |
      chcon -vR system_u:object_r:httpd_sys_content_t:s0 /usr/share/nginx/html/isos/
    delegate_to: localhost


#--------------------------------------Create OS image settings -------------------------------------------------------------------------------------------------------

  # OS image server setting is created or modified based on whether this particular resource is present or not

  - name: Check if the operating system image server setting 'OS_Image_ESXi7.0.u3_for_{{ inventory_hostname }}' exists
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ server_settings_API_version }}/server-settings?filter={{ filter | urlencode }}"
      method: GET
      headers:
        Authorization: "Bearer {{ access_token }}"
    vars:
      filter: "name eq 'OS_Image_ESXi7.0.u3_for_{{ inventory_hostname }}'"
    register: OS_image_server_setting
    delegate_to: localhost

  # - debug: var=OS_image_server_setting

  - name: Create an operating system image server setting 'OS_Image_ESXi7.0.u3_for_{{ inventory_hostname }}' if it does not exist
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ server_settings_API_version }}/server-settings"
      method: POST
      status_code: 201
      headers:
        Authorization: "Bearer {{ access_token }}"
        Content-Type: "application/json"
      body_format: json
      body:
        name:  "OS_Image_ESXi7.0.u3_for_{{ inventory_hostname }}"
        description: ""
        platformFamily: "Any"
        category:  "OS"
        settings:
          DEFAULT:
            osType: "VMWARE_ESXI"
            mediaUrl: 'http://{{ lookup("pipe","hostname") }}/isos/{{ inventory_hostname }}.iso'
    register: OS_image_server_setting_result
    delegate_to: localhost
    when: OS_image_server_setting.json.count == 0

  - name: Result of the 'OS_Image_ESXi7.0.u3_for_{{ inventory_hostname }}' creation task
    debug: var=OS_image_server_setting_result.msg
    when: OS_image_server_setting.json.count == 0

  - name: Set variables for the id and the resourceUri of the OS Image configuration 'OS_Image_ESXi7.0.u3_for_{{ inventory_hostname }}' just created 
    set_fact:
      OS_image_server_setting_id: "{{ OS_image_server_setting_result.json.id }}" 
      OS_image_server_setting_resourceuri: "{{ OS_image_server_setting_result.json.resourceUri }}"
    when: OS_image_server_setting.json.count == 0

  - name: Update the operating system image server setting 'OS_Image_ESXi7.0.u3_for_{{ inventory_hostname }}' if it does not exist
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ server_settings_API_version }}/server-settings/{{ OS_image_server_setting_id }}"
      method: PATCH
      status_code: 200
      headers:
        Authorization: "Bearer {{ access_token }}"
        Content-Type: "application/merge-patch+json"
      body_format: json
      body:
        name:  "OS_Image_ESXi7.0.u3_for_{{ inventory_hostname }}"
        description: ""
        platformFamily: "Any"
        category:  "OS"
        settings:
          DEFAULT:
            osType: "VMWARE_ESXI"
            mediaUrl: 'http://{{ lookup("pipe","hostname") }}/isos/{{ inventory_hostname }}.iso'
    vars: 
      OS_image_server_setting_id: "{{ OS_image_server_setting  | json_query('json.items[0].id') }}"
    register: OS_image_server_setting_result
    delegate_to: localhost
    when: OS_image_server_setting.json.count == 1

  # - debug: var=OS_image_server_setting_result  

  - name: Result of the 'OS_Image_ESXi7.0.u3_for_{{ inventory_hostname }}' update task
    debug: var=OS_image_server_setting_result.msg
    when: OS_image_server_setting.json.count == 1

  - name: Set variables for the id and the resourceUri of the OS Image configuration 'OS_Image_ESXi7.0.u3_for_{{ inventory_hostname }}' just updated
    set_fact:
      OS_image_server_setting_id: "{{ OS_image_server_setting | json_query('json.items[0].id') }}" 
      OS_image_server_setting_resourceuri: "{{ OS_image_server_setting | json_query('json.items[0].resourceUri') }}"
    when:  OS_image_server_setting.json.count == 1

  - debug: var=OS_image_server_setting_resourceuri
  
  - debug: var=OS_image_server_setting_id


#--------------------------------------Start OS image installation-----------------------------------------------------------------------------------------------------

  # Server group modification when NS204i is found => no local storage configuration definition
  
  - name: Update temporary group '{{ temporary_server_group_name }}' to add OS image installation settings with NS204i
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ groups_API_version }}/groups/{{ temporary_group_id }}"
      method: PATCH
      status_code: 200
      headers:
        Authorization: "Bearer {{ access_token }}"
        Content-Type: "application/merge-patch+json"
      body_format: json
      body:
        name: "{{ temporary_server_group_name }}"
        description: "Temporary server group for ESXi installation on server '{{ inventory_hostname }}'"
        serverSettingsUris: 
          - "{{ bios_server_setting_resourceuri }}"   
          - "{{ OS_image_server_setting_resourceuri }}"
        serverPolicies:
          onServerAdd:
            firmwareUpdate: false
            biosApplySettings: true
            storageConfiguration: false
            storageVolumeDeletion: false
            storageVolumeName: ""
            osInstall: true
          onSettingsApply:
            firmwareDowngrade: false
        # autoAddServerTags:
    register: server_group_result
    when:  NS204i_data is defined or no_NS204i_no_SR_MR_but_local_disk is defined
    delegate_to: localhost

  - name: Display response of the group '{{ temporary_server_group_name }}' update request with NS204i
    debug: var=server_group_result.msg
    when:  NS204i_data is defined or no_NS204i_no_SR_MR_but_local_disk is defined

  # Server group modification when NS204i is not found => set local storage configuration definition

  - name: Update temporary group '{{ temporary_server_group_name }}' to add OS image installation settings with storage controller (without NS204i)
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ groups_API_version }}/groups/{{ temporary_group_id }}"
      method: PATCH
      status_code: 200
      headers:
        Authorization: "Bearer {{ access_token }}"
        Content-Type: "application/merge-patch+json"
      body_format: json
      body:
        name: "{{ temporary_server_group_name }}"
        description: "Temporary server group for ESXi installation on server '{{ inventory_hostname }}'"
        serverSettingsUris: 
          - "{{ bios_server_setting_resourceuri }}"   
          - "{{ internal_storage_server_setting_resourceuri }}"       
          - "{{ OS_image_server_setting_resourceuri }}"
        serverPolicies:
          onServerAdd:
            firmwareUpdate: false
            biosApplySettings: true
            storageConfiguration: true
            storageVolumeDeletion: true
            storageVolumeName: "OS_boot_volume"
            osInstall: true
          onSettingsApply:
            firmwareDowngrade: false
        # autoAddServerTags:
    register: server_group_result
    when:  NS204i_data is undefined and SR_MR_storage_controller_data is defined
    delegate_to: localhost

  - name: Display response of the group '{{ temporary_server_group_name }}' update request with storage controller
    debug: var=server_group_result.msg
    when:  NS204i_data is undefined and SR_MR_storage_controller_data is defined

  - name: Start OS image installation in group '{{ temporary_server_group_name }}'
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ jobs_API_version }}/jobs"
      method: POST
      status_code: 200
      headers:
        Authorization: "Bearer {{ access_token }}"
        Content-Type: "application/json"
      body_format: json
      body:
        resourceUri: "{{ temporary_group_resourceuri }}"
        jobTemplateUri: "{{ GroupOSInstallation_job_template_resourceUri }}"
        data:
          devices:
            - "{{ server_id }}"
          parallel: true
          stopOnFailure: true
    register: group_os_installation_result
    delegate_to: localhost

  - name: Display response of the OS image installation request in group '{{ temporary_server_group_name }}' 
    debug: var=group_os_installation_result.msg


#--------------------------------------Wait for OS image installation to complete -------------------------------------------------------------------------------------
  
  # Monitor server activity

  - name: Wait for the OS image installation of server '{{ serial_number }}' to complete 
    uri:
      url:  "{{ ConnectivityEndpoint }}/compute-ops/{{ activities_API_version }}/activities?filter={{ filter | urlencode  }}"  
      method: GET
      headers:
        Authorization: "Bearer {{ access_token }}"
    vars: 
      filter: "associatedServerId eq '{{ server_id }}' and createdAt gt {{ start_time }}"      
      query: "json.items[?name=='Server OS Installation' && contains(message,'Operating system image installation task marked as complete')]"
    register: server_activities
    until: server_activities | json_query(query) 
    retries: 60
    delay: 60
    delegate_to: localhost

  # - debug: var=server_activities

  - name: Exit if operating system image installation task of server '{{ serial_number }}' failed to complete
    fail:
      msg: "The operating system image installation task of server '{{ serial_number }}' failed to complete!"
    when: server_activities.attempts >= 60


#--------------------------------------Delete temporary server group and server settings ------------------------------------------------------------------------------

  # Remove server from temporary group 

  - name: Unassign server '{{ serial_number }}' from temporary group '{{ temporary_server_group_name }}' 
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ groups_API_version }}/groups/{{ temporary_group_id }}/devices/{{ server_id }}"
      method: DELETE
      status_code: 204
      headers:
        Authorization: "Bearer {{ access_token }}"
    register: group_unassignment_result
    delegate_to: localhost

  - name: Wait for deletion to complete
    pause:
      seconds: 15

  - name: Display response of the temporary group unassignment task
    debug: var=group_unassignment_result.msg

  # Delete temporary group

  - name: Delete temporary group '{{ temporary_server_group_name }}' 
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ groups_API_version }}/groups/{{ temporary_group_id }}"
      method: DELETE
      status_code: 204
      headers:
        Authorization: "Bearer {{ access_token }}"
    register: server_group_deletion_result
    delegate_to: localhost

  - name: Display response of the temporary group deletion task
    debug: var=server_group_deletion_result.msg

  # Delete OS image server setting

  - name: Delete operating system image server setting 'OS_Image_ESXi7.0.u3_for_{{ inventory_hostname }}' 
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ server_settings_API_version }}/server-settings/{{ OS_image_server_setting_id }}"
      method: DELETE
      status_code: 204
      headers:
        Authorization: "Bearer {{ access_token }}"
    register: OS_image_server_setting_deletion_result
    delegate_to: localhost

  - name: Display response of the operating system image server setting deletion task
    debug: var=OS_image_server_setting_deletion_result.msg


#--------------------------------------Start post-installation steps --------------------------------------------------------------------------------------------------

  - name: Wait for '{{ os_ip_address }}' to respond on port 80...
    wait_for:
      timeout: 1800
      host: "{{ os_ip_address }}"
      port: 80
    delegate_to: localhost

  - name: Wait a little longer so that the ESX host is truly ready to be added to vCenter
    wait_for:
      timeout: 60
    delegate_to: localhost

  # Backup kickstart file for troubleshooting purposes

  - name: Create a kickstart backup directory if it does not exist
    file:
      path: "{{ staging_directory }}/kickstarts_backup/ESXi"
      state: directory
    delegate_to: localhost

  - name: Create a backup of the kickstart file named '{{ inventory_hostname }}_ks.cfg' in '{{ staging_directory }}/kickstarts_backup/ESXi' folder
    shell: |
      cp -f {{ staging_directory }}/baremetal/{{ inventory_hostname }}/KS.CFG {{ staging_directory }}/kickstarts_backup/ESXi/{{ inventory_hostname }}_ks.cfg
    delegate_to: localhost

  # Cleaning up staging files

  - name: Delete all related files from staging location and nginx web server folder
    become: yes
    shell: |
      rm -rf {{ inventory_hostname }}
      rm -f /usr/share/nginx/html/isos/{{ inventory_hostname }}.iso
      rm -rf /mnt/{{ inventory_hostname }}
    args:
      chdir: "{{ staging_directory }}/baremetal"
    delegate_to: localhost

  # vCenter and ESXi configuration

  - name: Set fact for the first host in inventory
    set_fact:
      is_first_host: "{{ play_hosts[0] == inventory_hostname }}"

  - name: Check if ESXi cluster '{{ cluster_name }}' exists in vCenter '{{ vcenter_hostname }}'
    community.vmware.vmware_cluster_info:
      hostname: '{{ vcenter_hostname }}'
      username: '{{ vcenter_username }}'
      password: '{{ vcenter_password }}'
      datacenter: "{{ datacenter_name }}"
      cluster_name: "{{ cluster_name }}"
      validate_certs: false
    register: cluster_facts
    delegate_to: localhost
    when: is_first_host

  # - debug: var=cluster_facts

  - name: Create ESXi cluster '{{ cluster_name }}' in vCenter '{{ vcenter_hostname }}' if not present 
    community.vmware.vmware_cluster:
      hostname: '{{ vcenter_hostname }}'
      username: '{{ vcenter_username }}'
      password: '{{ vcenter_password }}'
      datacenter_name: "{{ datacenter_name }}"
      cluster_name: "{{ cluster_name }}"
      state: present
      validate_certs: false
    when: is_first_host and (cluster_facts.clusters is not defined or cluster_name not in cluster_facts.clusters)
    # ignore_errors: yes # added as sometimes a failure is thrown saying "the name xyz already exists" when hosts are provisionned in parallel
    delegate_to: localhost
  
  - name: Pause for 10 seconds for the cluster to be ready
    ansible.builtin.pause:
      seconds: 10
    when: cluster_facts.clusters is not defined or cluster_name not in cluster_facts.clusters

  - name: Enable HA without admission control on '{{ cluster_name }}' cluster
    community.vmware.vmware_cluster_ha:
      hostname: '{{ vcenter_hostname }}'
      username: '{{ vcenter_username }}'
      password: '{{ vcenter_password }}'
      datacenter_name: "{{ datacenter_name }}"
      cluster_name: "{{ cluster_name }}"
      enable: true
      validate_certs: false
    ignore_errors: yes
    delegate_to: localhost
    when: is_first_host

  - name: Enable DRS with VM distribution across hosts for availability on '{{ cluster_name }}' cluster
    community.vmware.vmware_cluster_drs:
      hostname: '{{ vcenter_hostname }}'
      username: '{{ vcenter_username }}'
      password: '{{ vcenter_password }}'
      datacenter_name: "{{ datacenter_name }}"
      cluster_name: "{{ cluster_name }}"
      enable: true
      advanced_settings:
        'TryBalanceVmsPerHost': '1'
      validate_certs: false
    ignore_errors: yes
    delegate_to: localhost
    when: is_first_host

  - name: Pause for 10 seconds for the cluster to be ready
    ansible.builtin.pause:
      seconds: 10
    when: cluster_facts.clusters is not defined or cluster_name not in cluster_facts.clusters
        
  - name: Add ESXi host '{{ inventory_fqdn }}' to '{{ cluster_name }}' cluster 
    community.vmware.vmware_host:
      hostname: "{{ vcenter_hostname }}"
      username: "{{ vcenter_username }}"
      password: "{{ vcenter_password }}"
      datacenter_name: "{{ datacenter_name }}"
      cluster_name: "{{ cluster_name }}"
      esxi_hostname: "{{ inventory_fqdn }}"
      esxi_username: "root"
      esxi_password: "{{ root_password }}"
      state: present
      validate_certs: false
    delegate_to: localhost

  - name: Assign ESXi license to Host
    vcenter_license:
      hostname: "{{ vcenter_hostname }}"
      username: "{{ vcenter_username }}"
      password: "{{ vcenter_password }}"
      esxi_hostname: "{{ inventory_fqdn }}"
      license: "{{ esxi_license }}"
      state: present
      validate_certs: false
    ignore_errors: yes
    delegate_to: localhost

  - name: Add vmnic1 to standard switch vSwitch0
    vmware_vswitch:
      hostname: "{{ vcenter_hostname }}"
      username: "{{ vcenter_username }}"
      password: "{{ vcenter_password }}"
      esxi_hostname: "{{ inventory_fqdn }}"
      switch: vSwitch0
      nics:
        - vmnic0
        - vmnic1
      validate_certs: false
    ignore_errors: yes
    delegate_to: localhost

  - name: Pause for 10 seconds to give time for the vswitch0 configuration
    ansible.builtin.pause:
      seconds: 10

  - name: Add vMotion Portgroup to standard switch vSwitch0
    vmware_portgroup:
      hostname: "{{ vcenter_hostname }}"
      username: "{{ vcenter_username }}"
      password: "{{ vcenter_password }}"
      esxi_hostname: "{{ inventory_fqdn }}"
      switch: "vSwitch0"
      portgroup: "vMotion"
      validate_certs: false
    ignore_errors: yes
    delegate_to: localhost

  - name: Pause for 10 seconds to give time for the vswitch0 configuration
    ansible.builtin.pause:
      seconds: 10

  - name: Re-add ESXi host '{{ inventory_fqdn }}' to '{{ cluster_name }}' cluster (sometimes the host disconnects for an unknown reason)
    vmware_host:
      hostname: "{{ vcenter_hostname }}"
      username: "{{ vcenter_username }}"
      password: "{{ vcenter_password }}"
      datacenter_name: "{{ datacenter_name }}"
      cluster_name: "{{ cluster_name }}"
      esxi_hostname: "{{ inventory_fqdn }}"
      esxi_username: "root"
      esxi_password: "{{ root_password }}"
      state: present
      validate_certs: false
    delegate_to: localhost

  - name: Pause for 10 seconds to give time for the vswitch0 configuration
    ansible.builtin.pause:
      seconds: 10

  - name: Change Advanced Settings with Core Dump Warning Disable
    vmware_host_config_manager:
      hostname: "{{ vcenter_hostname }}"
      username: "{{ vcenter_username }}"
      password: "{{ vcenter_password }}"
      esxi_hostname: "{{ inventory_fqdn }}"
      options:
        "UserVars.SuppressCoredumpWarning": "1"
      validate_certs: false
    ignore_errors: yes
    delegate_to: localhost

  - name: Set the Power Management Policy to high-performance
    vmware_host_powermgmt_policy:
      hostname: "{{ vcenter_hostname }}"
      username: "{{ vcenter_username }}"
      password: "{{ vcenter_password }}"
      esxi_hostname: "{{ inventory_fqdn }}"
      policy: high-performance
      validate_certs: false
    ignore_errors: yes
    delegate_to: localhost

  - name: Configure NTP servers
    vmware_host_ntp:
      hostname: "{{ vcenter_hostname }}"
      username: "{{ vcenter_username }}"
      password: "{{ vcenter_password }}"
      esxi_hostname: "{{ inventory_fqdn }}"
      ntp_servers:
        - pool.ntp.org
      validate_certs: false
    ignore_errors: yes
    delegate_to: localhost

  - name: Start NTP Service and set to start at boot
    vmware_host_service_manager:
      hostname: "{{ vcenter_hostname }}"
      username: "{{ vcenter_username }}"
      password: "{{ vcenter_password }}"
      esxi_hostname: "{{ inventory_fqdn }}"
      validate_certs: false
      service_name: ntpd
      service_policy: on
      state: start
    ignore_errors: yes
    delegate_to: localhost

  - name: Start ESXi Shell Service and setting to enable at boot
    vmware_host_service_manager:
      hostname: "{{ vcenter_hostname }}"
      username: "{{ vcenter_username }}"
      password: "{{ vcenter_password }}"
      esxi_hostname: "{{ inventory_fqdn }}"
      validate_certs: false
      service_name: TSM
      service_policy: on
      state: start
    ignore_errors: yes
    delegate_to: localhost

  - name: Start SSH Service and setting to enable at boot
    vmware_host_service_manager:
      hostname: "{{ vcenter_hostname }}"
      username: "{{ vcenter_username }}"
      password: "{{ vcenter_password }}"
      esxi_hostname: "{{ inventory_fqdn }}"
      validate_certs: false
      service_name: TSM-SSH
      service_policy: on
      state: start
    ignore_errors: yes
    delegate_to: localhost


#--------------------------------------Capture firmware bundle information --------------------------------------------------------------------------------------------

  - name: Collect firmware bundles
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ firmware_bundles_API_version }}/firmware-bundles"
      method: GET
      headers:
        Authorization: "Bearer {{ access_token }}"
    register: firmwarebundles
    delegate_to: localhost
    when: is_first_host

  # - debug: var=firmwarebundles

  # Gen10 firmware bundle

  - name: Set variable for Gen10 firmware bundle '{{ Gen10_10p_firmware_bundle_name }}'
    set_fact:
      Gen10_10p_firmware_bundle_ID:  "{{ (firmwarebundles | json_query(query) )[0] }}"
    vars:
      query: "json.items[?releaseVersion=='{{ Gen10_10p_firmware_bundle_name }}'].id"
    when: is_first_host and (Gen10_10p_firmware_bundle_name is defined) and (Gen10_10p_firmware_bundle_name|length > 0) and (firmwarebundles | json_query(query) )[0] | default([]) != []

  - name:  Exit if Gen10 firmware bundle '{{ Gen10_10p_firmware_bundle_name }}' does not exist
    fail:
      msg: "Gen10 firmware bundle '{{ Gen10_10p_firmware_bundle_name }}' does not exist!"
    when: is_first_host and (Gen10_10p_firmware_bundle_name is defined) and (Gen10_10p_firmware_bundle_name|length > 0) and Gen10_10p_firmware_bundle_ID is not defined

  - debug: var=Gen10_10p_firmware_bundle_ID
    when: is_first_host and (Gen10_10p_firmware_bundle_name is defined) and (Gen10_10p_firmware_bundle_name|length > 0)
    
  # Gen10 associated patch

  - name: Set variable for '{{ Gen10_10p_patch_name_associated_with_firmware_bundle }}' associated patch for Gen10 firmware bundle '{{ Gen10_10p_firmware_bundle_name }}'
    set_fact:
      Gen10_10p_patch_firmware_ID: "{{ (firmwarebundles | json_query(query) )[0] }}"
    vars:
      query: "json.items[?releaseVersion=='{{ Gen10_10p_patch_name_associated_with_firmware_bundle }}'].id"
    when: is_first_host and (Gen10_10p_patch_name_associated_with_firmware_bundle is defined) and (Gen10_10p_patch_name_associated_with_firmware_bundle|length > 0) and (firmwarebundles | json_query(query) )[0] | default([]) != []

  - name: Exit if Gen10 associated patch '{{ Gen10_10p_patch_name_associated_with_firmware_bundle }}' does not exist
    fail:
      msg: "Gen10 associated patch '{{ Gen10_10p_patch_name_associated_with_firmware_bundle }}' does not exist!"
    when: is_first_host and (Gen10_10p_patch_name_associated_with_firmware_bundle is defined) and (Gen10_10p_patch_name_associated_with_firmware_bundle|length > 0) and Gen10_10p_patch_firmware_ID is not defined

  - debug: var=Gen10_10p_patch_firmware_ID
    when: is_first_host and (Gen10_10p_patch_name_associated_with_firmware_bundle is defined) and (Gen10_10p_patch_name_associated_with_firmware_bundle|length > 0)

  # Gen11 firmware bundle
  
  - name: Set variable for Gen11 firmware bundle '{{ Gen11_firmware_bundle_name }}'
    set_fact:
      Gen11_firmware_bundle_ID:  "{{ (firmwarebundles | json_query(query) )[0] }}"
    vars:
      query: "json.items[?releaseVersion=='{{ Gen11_firmware_bundle_name }}'].id"
    when: is_first_host and (Gen11_firmware_bundle_name is defined) and (Gen11_firmware_bundle_name|length > 0) and (firmwarebundles | json_query(query) )[0] | default([]) != []

  - name: Exit if Gen11 firmware bundle '{{ Gen11_firmware_bundle_name }}' does not exist
    fail:
      msg: "Gen11 firmware bundle '{{ Gen11_firmware_bundle_name }}' does not exist!"
    when: is_first_host and (Gen11_firmware_bundle_name is defined) and (Gen11_firmware_bundle_name|length > 0) and Gen11_firmware_bundle_ID is not defined

  - debug: var=Gen11_firmware_bundle_ID
    when: is_first_host and (Gen11_firmware_bundle_name is defined) and (Gen11_firmware_bundle_name|length > 0)

  # Gen11 associated patch
  
  - debug: var=Gen11_patch_name_associated_with_firmware_bundle
    when: is_first_host and (Gen11_patch_name_associated_with_firmware_bundle is defined) and (Gen11_patch_name_associated_with_firmware_bundle|length > 0)

  - name: Set variable for '{{ Gen11_patch_name_associated_with_firmware_bundle }}' associated patch for Gen11 firmware bundle '{{ Gen11_firmware_bundle_name }}'
    set_fact:
      Gen11_patch_firmware_ID:  "{{ (firmwarebundles | json_query(query) )[0] }}"
    vars:
      query: "json.items[?releaseVersion=='{{ Gen11_patch_name_associated_with_firmware_bundle }}'].id"
    when: is_first_host and (Gen11_patch_name_associated_with_firmware_bundle is defined) and (Gen11_patch_name_associated_with_firmware_bundle|length > 0) and (firmwarebundles | json_query(query) )[0] | default([]) != []

  - name: Exit if Gen11 associated patch '{{ Gen11_patch_name_associated_with_firmware_bundle }}' does not exist
    fail:
      msg: "Gen11 associated patch '{{ Gen11_patch_name_associated_with_firmware_bundle }}' does not exist!"
    when: is_first_host and (Gen11_patch_name_associated_with_firmware_bundle is defined) and (Gen11_patch_name_associated_with_firmware_bundle|length > 0) and Gen11_patch_firmware_ID is not defined

  - debug: var=Gen11_patch_firmware_ID
    when: is_first_host and (Gen11_patch_name_associated_with_firmware_bundle is defined) and (Gen11_patch_name_associated_with_firmware_bundle|length > 0) 

  # Setting final SPP variables if a fw patch exists

  - name: Set the final variable value for the Gen10 firmware bundle ID
    set_fact:
      Gen10_10p_firmware_bundle_ID: "{{ Gen10_10p_patch_firmware_ID }}"
    when: is_first_host and Gen10_10p_patch_firmware_ID is defined

  - name: Set the final variable value for the Gen11 firmware bundle ID
    set_fact:
      Gen11_firmware_bundle_ID: "{{ Gen11_patch_firmware_ID }}"
    when: is_first_host and Gen11_patch_firmware_ID is defined

  # Failure if firmware bundles set are not found

  - name: Fail if the firmware baselines for Gen10/Gen10+ and Gen11 servers could not be found.
    fail:
      msg: 'The firmware bundles for Gen10/Gen10+ and Gen11 servers could not be found, check your firmware baseline variables.' 
    when: is_first_host and Gen10_10p_firmware_bundle_ID is not defined and Gen11_firmware_bundle_ID is not defined

  - name: Fail if the firmware baseline for Gen10/Gen10+ servers could not be found.
    fail:
      msg: 'The firmware bundle for Gen10/Gen10+ servers could not be found, check your firmware baseline variables.' 
    when: is_first_host and Gen10_10p_firmware_bundle_ID is not defined 

  - name: Fail if the firmware baseline for Gen11 servers could not be found.
    fail:
      msg: 'The firmware bundle for Gen11 servers could not be found, check your firmware baseline variables.' 
    when: is_first_host and Gen11_firmware_bundle_ID is not defined 
 
  # Set firmware bundle id for the server generation

  - name: Set firmware bundle id for Gen10/Gen10+ server
    set_fact: 
      bundle_id: "{{ Gen10_10p_firmware_bundle_ID }}"
    when: is_first_host and server_generation == "GEN_10"
 
  - name: Set firmware bundle id for Gen11 server
    set_fact: 
      bundle_id: "{{ Gen11_firmware_bundle_ID }}"
    when: is_first_host and server_generation == "GEN_11"

  - debug: var=bundle_id
    when: is_first_host

 # Create the firmware server setting 

  - name: Check if the firmware server setting '{{ firmware_server_setting_name }}' exists
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ server_settings_API_version }}/server-settings?filter={{ filter | urlencode }}"
      method: GET
      headers:
        Authorization: "Bearer {{ access_token }}"
    vars:
      filter: "name eq '{{ firmware_server_setting_name }}'"
    register: firmware_server_setting
    delegate_to: localhost   
    when: is_first_host

  # - debug: var=firmware_server_setting

  - name: Create the firmware server setting '{{ firmware_server_setting_name }}' 
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ server_settings_API_version }}/server-settings"
      method: POST
      status_code: 201
      headers:
        Authorization: "Bearer {{ access_token }}"
        Content-Type: "application/json"
      body_format: json
      body:
        name: "{{ firmware_server_setting_name }}"
        description: "Firmware baseline for ESXi 7.0.u3"
        category: "FIRMWARE"
        platformFamily: "Any"
        settings:
          GEN10:
            id: "{{ Gen10_10p_firmware_bundle_ID }}"
          GEN11:
            id: "{{ Gen11_firmware_bundle_ID }}"
    register: firmware_server_setting_result
    when: is_first_host and firmware_server_setting.json.count == 0
    delegate_to: localhost

  - name: Display response of the firmware server setting '{{ firmware_server_setting_name }}' creation request
    debug: var=firmware_server_setting_result.msg
    when: is_first_host and firmware_server_setting.json.count == 0

  - name: Set variable for the resourceuri of the firmware server setting '{{ firmware_server_setting_name }}' just created
    set_fact: 
      firmware_server_setting_resourceuri: "{{ firmware_server_setting_result.json.resourceUri }}"
    when: is_first_host and firmware_server_setting.json.count == 0

  - name: Update the firmware server setting '{{ firmware_server_setting_name }}' 
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ server_settings_API_version }}/server-settings/{{ firmware_server_setting_id }}"
      method: PATCH
      status_code: 200
      headers:
        Authorization: "Bearer {{ access_token }}"
        Content-Type: "application/merge-patch+json"
      body_format: json
      body:
        name: "{{ firmware_server_setting_name }}"
        description: "Firmware baseline for ESXi 7.0.u3"
        category: "FIRMWARE"
        platformFamily: "Any"
        settings:
          GEN10:
            id: "{{ Gen10_10p_firmware_bundle_ID }}"
          GEN11:
            id: "{{ Gen11_firmware_bundle_ID }}"
    vars: 
      firmware_server_setting_id: "{{ firmware_server_setting | json_query('json.items[0].id')  }}"
    register: firmware_server_setting_result
    when: is_first_host and firmware_server_setting.json.count == 1
    delegate_to: localhost

  - name: Display response of the firmware server setting '{{ firmware_server_setting_name }}' update task
    debug: var=firmware_server_setting_result.msg
    when: is_first_host and firmware_server_setting.json.count == 1
    
  - name: Set variable for the resourceuri of the firmware server setting '{{ firmware_server_setting_name }}' just updated
    set_fact: 
      firmware_server_setting_resourceuri: "{{ firmware_server_setting | json_query('json.items[0].resourceUri') }}"
    when: is_first_host and firmware_server_setting.json.count == 1

  - debug: var=firmware_server_setting_resourceuri
    when: is_first_host


#--------------------------------------Firmware update preparation: Create a definitive server group or update if existing --------------------------------------------

 # Check if definitive server group exists
  
  - name: Check if definitive group '{{ server_group_name }}' already exist
    uri:
      url:  "{{ ConnectivityEndpoint }}/compute-ops/{{ groups_API_version }}/groups?filter={{ filter | urlencode }}"
      method: GET
      headers:
        Authorization: "Bearer {{ access_token }}"
    vars: 
      filter: "name eq '{{ server_group_name }}'"      
    register: definitive_server_group
    delegate_to: localhost
    when: is_first_host

  # - debug: var=definitive_server_group

  # Create the definitive server group if it does not exist

  - name: Create definitive group '{{ server_group_name }}' if it does not exist
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ groups_API_version }}/groups"
      method: POST
      status_code: 201
      headers:
        Authorization: "Bearer {{ access_token }}"
        Content-Type: "application/json"
      body_format: json
      body:
        name: "{{ server_group_name }}"
        description: "Server group for ESXi servers"
        serverSettingsUris: 
          - "{{ bios_server_setting_resourceuri }}"     
          - "{{ firmware_server_setting_resourceuri }}"     
        serverPolicies:
          onServerAdd:
            firmwareUpdate: false
            biosApplySettings: false
            storageConfiguration: false
            storageVolumeDeletion: false
            storageVolumeName: ""
            osInstall: false
          onSettingsApply:
            firmwareDowngrade: "{{ firmware_downgrade_policy }}"
        # autoAddServerTags:
    register: definitive_server_group_result
    when: is_first_host and definitive_server_group.json.count == 0
    delegate_to: localhost

  - name: Display response of the definitive group '{{ server_group_name }}' creation request
    debug: var=definitive_server_group_result.msg
    when: is_first_host and definitive_server_group.json.count == 0

  - name: Set variables for the id and the resourceUri of the definitive group '{{ server_group_name }}' just created
    set_fact:
      definitive_group_id: "{{ definitive_server_group_result.json.id }}" 
      definitive_group_resourceuri: "{{ definitive_server_group_result.json.resourceUri }}"
    when: is_first_host and definitive_server_group.json.count == 0

  # Update the definitive server group if the group exists
    
  - name: Update definitive group '{{ server_group_name }}' if it does exist
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ groups_API_version }}/groups/{{ group_id }}"
      method: PATCH
      status_code: 200
      headers:
        Authorization: "Bearer {{ access_token }}"
        Content-Type: "application/merge-patch+json"
      body_format: json
      body:
        name: "{{ server_group_name }}"
        description: "Server group for ESXi server"
        serverSettingsUris: 
          - "{{ bios_server_setting_resourceuri }}"   
          - "{{ firmware_server_setting_resourceuri }}"     
        serverPolicies:
          onServerAdd:
            firmwareUpdate: false
            biosApplySettings: false
            storageConfiguration: false
            storageVolumeDeletion: false
            storageVolumeName: ""
            osInstall: false
          onSettingsApply:
            firmwareDowngrade: "{{ firmware_downgrade_policy }}"
        # autoAddServerTags:
    vars: 
      group_id: "{{ definitive_server_group  | json_query('json.items[0].id') }}"
    register: definitive_server_group_result
    when: is_first_host and definitive_server_group.json.count == 1
    delegate_to: localhost

  - name: Display response of the group '{{ server_group_name }}' update request
    debug: var=definitive_server_group_result.msg
    when: is_first_host and definitive_server_group.json.count == 1

  - name: Set variables for the id and the resourceUri of the existing definitive group '{{ server_group_name }}' just updated
    set_fact:
      definitive_group_id: "{{ definitive_server_group | json_query('json.items[0].id') }}" 
      definitive_group_resourceuri: "{{ definitive_server_group | json_query('json.items[0].resourceUri') }}"
    when: is_first_host and definitive_server_group.json.count == 1

  - debug: var=definitive_group_id  
    when: is_first_host

  - debug: var=definitive_group_resourceuri
    when: is_first_host


#--------------------------------------Firmware update preparation: Put server in maintenance mode --------------------------------------------------------------------
  
  - name: Re-add ESXi host '{{ inventory_fqdn }}' to '{{ cluster_name }}' cluster (sometimes the host disconnects for an unknown reason)
    vmware_host:
      hostname: "{{ vcenter_hostname }}"
      username: "{{ vcenter_username }}"
      password: "{{ vcenter_password }}"
      datacenter_name: "{{ datacenter_name }}"
      cluster_name: "{{ cluster_name }}"
      esxi_hostname: "{{ inventory_fqdn }}"
      esxi_username: "root"
      esxi_password: "{{ root_password }}"
      state: present
      validate_certs: false
    delegate_to: localhost

  - name: Wait until VMware host is 'connected' in vCenter
    community.vmware.vmware_host_facts:
      hostname: "{{ vcenter_hostname }}"
      username: "{{ vcenter_username }}"
      password: "{{ vcenter_password }}"
      esxi_hostname: "{{ inventory_fqdn }}"
      validate_certs: false
    register: host_facts 
    delegate_to: localhost
    delay: 10
    timeout: 900 # 15 minutes
    until: host_facts.ansible_facts.ansible_host_connection_state == "connected"

  - name: Place ESXi host '{{ inventory_fqdn }}' into maintenance mode
    community.vmware.vmware_maintenancemode:
      hostname: "{{ vcenter_hostname }}"
      username: "{{ vcenter_username }}"
      password: "{{ vcenter_password }}"
      esxi_hostname: "{{ inventory_fqdn }}"
      validate_certs: false
      evacuate: true
      timeout: 3600
      state: present
    delegate_to: localhost


#--------------------------------------Adding server to definitive server group and starting firmware update ----------------------------------------------------------
      
  # Capture the start time of the firmware update
  - name: Gather subset facts on localhost
    setup:
      gather_subset: [all]
    delegate_to: localhost

  - name: Capture the start time of the firmware update (will be used later to filter COM activities, etc.)
    set_fact:
      firmware_update_start_time: "{{ ansible_date_time.iso8601 }}"

  - name: Display the start time of the firmware update
    debug: 
      msg: "{{ firmware_update_start_time }}"

  - name: Get definitive group '{{ server_group_name }}' information
    uri:
      url:  "{{ ConnectivityEndpoint }}/compute-ops/{{ groups_API_version }}/groups?filter={{ filter | urlencode }}"
      method: GET
      headers:
        Authorization: "Bearer {{ access_token }}"
    vars: 
      filter: "name eq '{{ server_group_name }}'"      
    register: definitive_server_group
    delegate_to: localhost

  - name: Set variable for existing definitive group '{{ server_group_name }}' id
    set_fact:
      definitive_group_id: "{{ definitive_server_group | json_query('json.items[0].id') }}" 

  # Check if the server is already member of the definitive server group if it does exist

  - name: Check if server '{{ serial_number }}' is already member of definitive server group '{{ server_group_name }}' 
    set_fact: 
      server_found_in_definitive_group: "{{ definitive_server_group  | json_query(query) }}"
    vars:
      query: "json.items[0].devices[?serial=='{{ serial_number }}']"
    when: definitive_server_group.json.count == 1
      
  # - debug: var=server_found_in_definitive_group
    
  # Add server to the definitive server group 

  - name: Assign server '{{ serial_number }}' to definitive server group '{{ server_group_name }}'
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ groups_API_version }}/groups/{{ definitive_group_id }}/devices"
      method: POST
      headers:
        Authorization: "Bearer {{ access_token }}"
        Content-Type: "application/json"
      body_format: json
      body:
        devices:
          - serverId: "{{ server_id }}"
    register: group_assignment_result
    when: server_found_in_definitive_group is not defined or server_found_in_definitive_group | length == 0
    delegate_to: localhost

  - name: Display response of the group assignment task
    debug: var=group_assignment_result.msg
    when: server_found_in_definitive_group is not defined or server_found_in_definitive_group | length == 0

  - name: Wait for assignment to truly complete
    pause:
      seconds: 15
    when: server_found_in_definitive_group is not defined or server_found_in_definitive_group | length == 0
  
  # Start an HPE drivers, software and firmware update job

  # To run a firmware update in parallel on each host and save time, it is necessary to use the group firmware update job
  # This job will only be executed on the first host in the Ansible inventory

  # Get the list of devices in the definitive server group with the first host only

  - name: Get definitive group '{{ server_group_name }}' information (first host only)
    uri:
      url:  "{{ ConnectivityEndpoint }}{{ definitive_group_resourceuri  }}"
      method: GET
      headers:
        Authorization: "Bearer {{ access_token }}"
    register: definitive_server_group
    delegate_to: localhost
    when: is_first_host

  - name: Set fact for the list of server IDs member of the definitive server group (first host only)
    set_fact:
      server_ids: "{{ definitive_server_group.json.devices  | map(attribute='id') | list  }}"
    when: is_first_host

  - name: Display the server IDs found (first host only)
    debug: var=server_ids
    when: is_first_host

  # If updating HPE drivers, software and firmware takes a long time, it's safer to ask for a new COM token now

  - name: Create a new HPE Compute Ops Management session to avoid token expiration during the firmware update job
    import_tasks: files/Create_COM_session.yml

  # Start a group firmware update job with the first host only

  - name: Start a group firmware update job using the defined firmware baseline (first host only)
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ jobs_API_version }}/jobs"
      method: POST
      status_code: 200
      headers:
        Authorization: "Bearer {{ access_token }}"
        Content-Type: "application/json"
      body_format: json
      body:
        resourceUri: "{{ definitive_group_resourceuri }}"
        jobTemplateUri: "{{ GroupFirmwareUpdate_job_template_resourceUri }}"
        data:
          devices: "{{ server_ids }}"
          parallel: true
          stopOnFailure: false
          installSWDrivers: "{{ install_SWDrivers_policy }}"
          downgrade: "{{ firmware_downgrade_policy }}"
          powerOff: false
    register: group_firmware_update_job
    delegate_to: localhost
    when: is_first_host

  - name: Display response of the group firmware update job (first host only)
    debug: var=group_firmware_update_job.msg
    when: is_first_host


#--------------------------------------Wait until the update of the HPE server drivers, software and firmware is complete. --------------------------------------------
 
  - name: Capture the resourceUri of the group firmware update job (first host only)
    set_fact:
      group_firmware_update_job_resourceUri: "{{ group_firmware_update_job.json.resourceUri }}"
    when: is_first_host

  - name: Display the group firmware update job resource uri (first host only)
    debug: var=group_firmware_update_job_resourceUri
    when: is_first_host
 
  - name: Wait for the group firmware update job to complete (first host only)
    uri:
      url: "{{ ConnectivityEndpoint }}{{ group_firmware_update_job_resourceUri }}"
      method: GET
      return_content: yes
      headers:
        Authorization: "Bearer {{ access_token }}"
    retries: 600
    delay: 60
    until: >
      (group_firmware_update_job_status.json.state == "COMPLETE" or 
      group_firmware_update_job_status.json.state == "ERROR")
    register: group_firmware_update_job_status
    ignore_errors: yes
    changed_when: false
    delegate_to: localhost
    when: is_first_host

  # - debug: var=group_firmware_update_job_status

  - name: Display the group firmware update job result (first host only)
    debug: 
      msg:
        - "State: {{ group_firmware_update_job_status.json.state }}"
        - "ResultCode: {{ group_firmware_update_job_status.json.resultCode }}"
        - "Status: {{ group_firmware_update_job_status.json.status }}"
    when: is_first_host

  # Display the server firmware update activity status

  - name: Get the latest activity of server '{{ serial_number }}'
    uri:
      url:  "{{ ConnectivityEndpoint }}/compute-ops/{{ activities_API_version }}/activities?filter={{ filter | urlencode  }}"  
      method: GET
      headers:
        Authorization: "Bearer {{ access_token }}"
    vars: 
      filter: "associatedServerId eq '{{ server_id }}' and createdAt gt {{ firmware_update_start_time }}"      
    register: Server_activity_status
    delegate_to: localhost

  # - debug: var=Server_activity_status

  - name: Extract items containing 'Firmware update'  
    set_fact:
      firmware_update_items: "{{ (Server_activity_status | json_query(query))[0] }}"
    vars:
      query: "json.items[? contains(name, 'Firmware update') && contains(groupDisplayName, '{{ server_group_name }}')]"

  # - debug: var=firmware_update_items

  - name: Display the firmware update activity status when successful 
    vars:
      msg: |
          Message: {{ firmware_update_items.message }}
    debug:
      msg: "{{ msg.split('\n') }}"
    when: firmware_update_items.message is search('Firmware update successful', ignorecase=True)

  - name: Display the firmware update activity status with recommanded actions when failed
    vars:
      msg: |
          Message: {{ firmware_update_items.message }}

          Recommended action:
          {{ firmware_update_items.recommendedAction  | regex_replace('\\n', '\n') | regex_replace('\n\n', '\n') }}
    debug:
      msg: "{{ msg.split('\n') }}"
    when: firmware_update_items.message is search('Firmware update failed', ignorecase=True)
    
  # Capture last firmware update information

  - name: Capture server information   
    uri:
      url: "{{ ConnectivityEndpoint }}/compute-ops/{{ servers_API_version }}/servers?filter=hardware/serialNumber%20eq%20'{{ serial_number }}'"
      method: GET
      headers:
        Authorization: "Bearer {{ access_token }}"
    register: server
    delegate_to: localhost
  
  - name: Capture last firmware update information if any
    set_fact:
      last_firmware_update: "{{ server | json_query('json.items[0].lastFirmwareUpdate') }}"
    when: (server | json_query('json.items[0].lastFirmwareUpdate')) is not none

  # - debug: var=last_firmware_update.attemptedAt

  - name: Display server last firmware update information if up-to-date
    debug: 
      msg: "{{ last_firmware_update }}"  
    when: last_firmware_update is defined and last_firmware_update.attemptedAt > firmware_update_start_time


#--------------------------------------Exit ESXi server from maintenance mode -----------------------------------------------------------------------------------------

  # Wait until the ESXi host is accessible again if a reboot was necessary to activate some firmware components

  - name: Wait until VMware host is 'connected' in vCenter
    community.vmware.vmware_host_facts:
      hostname: "{{ vcenter_hostname }}"
      username: "{{ vcenter_username }}"
      password: "{{ vcenter_password }}"
      esxi_hostname: "{{ inventory_fqdn }}"
      validate_certs: false
    register: host_facts 
    delegate_to: localhost
    delay: 10
    timeout: 900 # 15 minutes
    until: host_facts.ansible_facts.ansible_host_connection_state == "connected"

  - name: Take ESXi host '{{ inventory_fqdn }}' out of maintenance mode
    community.vmware.vmware_maintenancemode:
      hostname: "{{ vcenter_hostname }}"
      username: "{{ vcenter_username }}"
      password: "{{ vcenter_password }}"
      esxi_hostname: "{{ inventory_fqdn }}"
      validate_certs: false
      state: absent
    ignore_errors: yes
    delegate_to: localhost


#--------------------------------------Display end-of-installation message --------------------------------------------------------------------------------------------

  # Get the runtime

  - name: Force update of current timestamp
    setup: filter='ansible_date_time'
    delegate_to: localhost

  - name: Get runtime
    set_fact:
      runtime: "{{ ((ansible_date_time.iso8601[:19] | to_datetime('%Y-%m-%dT%H:%M:%S')) - (start_time[:19] | to_datetime('%Y-%m-%dT%H:%M:%S'))) }}"

  # Display server installation completed message

  - name: Status of the OS installation with the firmware update with HPE drivers and software
    debug:
      msg:
        - "{{ inventory_hostname }}.{{domain}} installation and firmware update completed successfully!"
        - "OS is configured and running with the HPE drivers and software and added to the vCenter cluster '{{ cluster_name }}'"
        - "To SSH to the new host from Ansible control node, use: ssh root@{{ inventory_hostname }}.{{domain}}"
        - "The provisioning task took {{ runtime }}."
    when: (firmware_update_items.message is search('Firmware update successful', ignorecase=True)) and (install_SWDrivers_policy|bool == True)

  - name: Status of the OS installation with the firmware update without HPE drivers and software
    debug:
      msg:
        - "{{ inventory_hostname }}.{{domain}} installation and firmware update completed successfully!"
        - "OS is configured and running and added to the vCenter cluster '{{ cluster_name }}'"
        - "To SSH to the new host from Ansible control node, use: ssh root@{{ inventory_hostname }}.{{domain}}"
        - "The provisioning task took {{ runtime }}."
    when: (firmware_update_items.message is search('Firmware update successful', ignorecase=True)) and (install_SWDrivers_policy|bool == False)    

  - name: Status of the OS installation with firmware update failure
    debug:
      msg:
        - "{{ inventory_hostname }}.{{domain}} installation completed but the firmware update operation failed to complete!" 
        - "OS is configured and running and added to the vCenter cluster '{{ cluster_name }}'"
        - "Refer to the individual server activity entries in the HPE Compute Ops Management UI for more details."
        - "To SSH to the new host from Ansible control node, use: ssh root@{{ inventory_hostname }}.{{domain}}"
        - "The provisioning task took {{ runtime }}."
    when: (firmware_update_items.message is search('Firmware update failed', ignorecase=True)) or (group_firmware_update_job_status.json.resultCode is none)

